<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Agency Dashboard</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/core@1.0.0-beta17/dist/css/tabler.min.css">
  <style>
    .status-badge { font-size: 0.75rem; }
    #submitResult { display: none; }
    #submitResult.show { display: block; }
    .table-component { margin-bottom: 0; }
    .table-component td, .table-component th { vertical-align: middle; padding: 0.5rem; }
    .table-component .task-col { max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .table-component .session-id { font-family: monospace; font-size: 0.85rem; }
    .table-component .btn-sm { padding: 0.2rem 0.5rem; font-size: 0.75rem; }
    .empty-message { color: var(--tblr-muted); font-style: italic; padding: 1rem; }
  </style>
</head>
<body class="theme-light">
  <div class="page">
    <header class="navbar navbar-expand-md navbar-light d-print-none">
      <div class="container-xl">
        <h1 class="navbar-brand navbar-brand-autodark d-none-navbar-horizontal pe-0 pe-md-3">
          <span class="text-primary">Agency</span> Dashboard
        </h1>
        <div class="navbar-nav flex-row order-md-last">
          <span class="badge bg-green-lt">Connected</span>
        </div>
      </div>
    </header>

    <div class="page-wrapper">
      <div class="page-body">
        <div class="container-xl">
          <!-- Task Submission -->
          <div class="card mb-3">
            <div class="card-header">
              <h3 class="card-title">Submit Task</h3>
            </div>
            <div class="card-body">
              <form id="taskForm">
                <div class="row">
                  <div class="col-md-4 mb-3">
                    <label class="form-label">Agent</label>
                    <select class="form-select" id="agentSelect" required>
                      <option value="">Select an idle agent...</option>
                    </select>
                  </div>
                  <div class="col-md-4 mb-3">
                    <label class="form-label">Session</label>
                    <select class="form-select" id="sessionSelect">
                      <option value="">New session</option>
                    </select>
                  </div>
                  <div class="col-md-2 mb-3">
                    <label class="form-label">Timeout (s)</label>
                    <input type="number" class="form-control" id="timeout" value="1800" min="1">
                  </div>
                  <div class="col-md-2 mb-3">
                    <label class="form-label">Model</label>
                    <select class="form-select" id="model">
                      <option value="">Auto</option>
                      <option value="opus">Opus</option>
                      <option value="sonnet">Sonnet</option>
                      <option value="haiku">Haiku</option>
                    </select>
                  </div>
                </div>
                <div class="mb-3">
                  <label class="form-label">Prompt</label>
                  <textarea class="form-control" id="prompt" rows="4" required placeholder="Describe the task..."></textarea>
                </div>
                <button type="submit" class="btn btn-primary" id="submitBtn">
                  <span class="spinner-border spinner-border-sm d-none" id="submitSpinner"></span>
                  Submit Task
                </button>
              </form>
              <div id="submitResult" class="mt-3 alert"></div>
            </div>
          </div>

          <!-- Sessions Section -->
          <div class="card mb-3">
            <div class="card-header">
              <h3 class="card-title">Sessions</h3>
              <div class="card-actions">
                <span class="badge bg-purple" id="sessionCount">0</span>
              </div>
            </div>
            <div class="table-responsive">
              <table class="table table-vcenter table-component" id="sessionTable">
                <thead>
                  <tr>
                    <th style="width: 60px;">Status</th>
                    <th style="width: 120px;">Session</th>
                    <th>Agent</th>
                    <th style="width: 60px;">Tasks</th>
                    <th>Last Prompt</th>
                    <th style="width: 80px;"></th>
                  </tr>
                </thead>
                <tbody id="sessionTableBody">
                  <tr><td colspan="6" class="empty-message">No active sessions</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Agents Section -->
          <div class="card mb-3">
            <div class="card-header">
              <h3 class="card-title">Agents</h3>
              <div class="card-actions">
                <span class="badge bg-azure" id="agentCount">0</span>
              </div>
            </div>
            <div class="table-responsive">
              <table class="table table-vcenter table-component" id="agentTable">
                <thead>
                  <tr>
                    <th style="width: 60px;">Status</th>
                    <th>URL</th>
                    <th style="width: 80px;">Version</th>
                    <th style="width: 80px;">Uptime</th>
                    <th>Current Task</th>
                  </tr>
                </thead>
                <tbody id="agentTableBody">
                  <tr><td colspan="5" class="empty-message">No agents discovered</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Directors Section -->
          <div class="card mb-3">
            <div class="card-header">
              <h3 class="card-title">Directors</h3>
              <div class="card-actions">
                <span class="badge bg-purple" id="directorCount">0</span>
              </div>
            </div>
            <div class="table-responsive">
              <table class="table table-vcenter table-component" id="directorTable">
                <thead>
                  <tr>
                    <th style="width: 60px;">Status</th>
                    <th>URL</th>
                    <th style="width: 80px;">Version</th>
                    <th style="width: 80px;">Uptime</th>
                  </tr>
                </thead>
                <tbody id="directorTableBody">
                  <tr><td colspan="4" class="empty-message">No directors discovered</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Active Task Monitor -->
          <div class="card" id="taskMonitor" style="display: none;">
            <div class="card-header">
              <h3 class="card-title">Task Monitor</h3>
            </div>
            <div class="card-body">
              <div id="taskDetails"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tabler/core@1.0.0-beta17/dist/js/tabler.min.js"></script>
  <script>
    // Get auth token from URL
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token') || '';

    // Tracked task for monitoring
    let activeTask = null;

    // Sessions storage - fetched from server for global access
    let sessions = {};
    let sessionOrder = []; // Maintain server's sort order (newest first)

    // ETag for caching
    let dashboardETag = null;

    // Adaptive polling interval (ms)
    const POLL_IDLE = 5000;    // 5s when idle
    const POLL_ACTIVE = 1000;  // 1s when task running
    let pollInterval = POLL_IDLE;
    let refreshTimer = null;

    // Save task to server session
    async function saveSessionTask(sessionId, agentUrl, taskId, state, prompt) {
      try {
        await api('/api/sessions', {
          method: 'POST',
          body: JSON.stringify({
            session_id: sessionId,
            agent_url: agentUrl,
            task_id: taskId,
            state: state,
            prompt: prompt
          })
        });
      } catch (err) {
        console.error('Failed to save session task:', err);
      }
    }

    // Update task state on server
    async function updateSessionTaskState(sessionId, taskId, state) {
      try {
        await api(`/api/sessions/${sessionId}/tasks/${taskId}`, {
          method: 'PUT',
          body: JSON.stringify({ state: state })
        });
      } catch (err) {
        console.error('Failed to update session task state:', err);
      }
    }

    // API helper
    async function api(path, options = {}) {
      const url = new URL(path, window.location.origin);
      if (token) url.searchParams.set('token', token);

      const resp = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...(options.headers || {})
        }
      });

      if (!resp.ok) {
        const err = await resp.json().catch(() => ({ message: resp.statusText }));
        throw new Error(err.message || `HTTP ${resp.status}`);
      }
      return resp.json();
    }

    // Fetch dashboard data with ETag support
    async function fetchDashboard() {
      const url = new URL('/api/dashboard', window.location.origin);
      if (token) url.searchParams.set('token', token);

      const headers = { 'Content-Type': 'application/json' };
      if (dashboardETag) headers['If-None-Match'] = dashboardETag;

      const resp = await fetch(url, { headers });

      if (resp.status === 304) {
        return null; // No change
      }

      if (!resp.ok) {
        const err = await resp.json().catch(() => ({ message: resp.statusText }));
        throw new Error(err.message || `HTTP ${resp.status}`);
      }

      dashboardETag = resp.headers.get('ETag');
      return resp.json();
    }

    // Render agent table row
    function renderAgentRow(agent) {
      const stateColors = {
        'idle': 'bg-green',
        'working': 'bg-yellow',
        'cancelling': 'bg-orange'
      };
      const stateColor = stateColors[agent.state] || 'bg-secondary';

      let taskInfo = '—';
      if (agent.current_task) {
        const preview = escapeHtml(agent.current_task.prompt_preview || '');
        taskInfo = `<span class="task-col" title="${preview}">${agent.current_task.id}: ${preview}</span>`;
      }

      return `
        <tr>
          <td><span class="badge ${stateColor} status-badge" title="${agent.state}">${stateIcon(agent.state)} ${agent.state}</span></td>
          <td class="text-muted small">${agent.url}</td>
          <td class="small">${agent.version || '—'}</td>
          <td class="small">${formatUptime(agent.uptime_seconds)}</td>
          <td class="small">${taskInfo}</td>
        </tr>`;
    }

    // Render director table row
    function renderDirectorRow(director) {
      return `
        <tr>
          <td><span class="badge bg-purple status-badge">dir</span></td>
          <td class="text-muted small">${director.url}</td>
          <td class="small">${director.version || '—'}</td>
          <td class="small">${formatUptime(director.uptime_seconds)}</td>
        </tr>`;
    }

    // Render session table row
    function renderSessionRow(sessionId, session) {
      const taskCount = session.tasks ? session.tasks.length : 0;
      const lastTask = session.tasks && session.tasks.length > 0 ? session.tasks[session.tasks.length - 1] : null;
      const stateColors = {
        'completed': 'bg-green',
        'failed': 'bg-red',
        'working': 'bg-yellow',
        'queued': 'bg-secondary'
      };
      const lastState = lastTask ? lastTask.state : 'unknown';
      const lastPrompt = lastTask ? escapeHtml((lastTask.prompt || '').slice(0, 50)) : '—';
      const fullPrompt = lastTask ? escapeHtml(lastTask.prompt || '') : '';

      return `
        <tr>
          <td><span class="badge ${stateColors[lastState] || 'bg-secondary'} status-badge" title="${lastState}">${stateIcon(lastState)}</span></td>
          <td class="session-id">${sessionId.slice(0, 8)}...</td>
          <td class="text-muted small">${session.agentUrl}</td>
          <td class="text-center">${taskCount}</td>
          <td class="small task-col" title="${fullPrompt}">${lastPrompt}${(lastTask?.prompt || '').length > 50 ? '...' : ''}</td>
          <td><button class="btn btn-sm btn-outline-primary" onclick="continueSession('${sessionId}')">Continue</button></td>
        </tr>`;
    }

    // Update sessions display
    function updateSessionsUI() {
      const sessionTableBody = document.getElementById('sessionTableBody');
      const sessionSelect = document.getElementById('sessionSelect');

      document.getElementById('sessionCount').textContent = sessionOrder.length;

      if (sessionOrder.length > 0) {
        sessionTableBody.innerHTML = sessionOrder.map(id => renderSessionRow(id, sessions[id])).join('');
      } else {
        sessionTableBody.innerHTML = '<tr><td colspan="6" class="empty-message">No active sessions</td></tr>';
      }

      // Update session dropdown, preserving current selection
      const currentSessionValue = sessionSelect.value;
      sessionSelect.innerHTML = '<option value="">New session</option>' +
        sessionOrder.map(id => {
          const s = sessions[id];
          const taskCount = s.tasks ? s.tasks.length : 0;
          return `<option value="${id}">${id.slice(0, 8)}... (${taskCount} tasks, ${s.agentUrl})</option>`;
        }).join('');
      if (currentSessionValue && sessionOrder.includes(currentSessionValue)) {
        sessionSelect.value = currentSessionValue;
      }
    }

    // Continue session - pre-fill form
    function continueSession(sessionId) {
      const session = sessions[sessionId];
      if (!session) return;

      document.getElementById('sessionSelect').value = sessionId;
      document.getElementById('agentSelect').value = session.agentUrl;
      document.getElementById('prompt').focus();
    }

    // Update dashboard
    async function refresh() {
      try {
        const data = await fetchDashboard();

        // If 304 (no change), only poll active task
        if (data === null) {
          if (activeTask) await pollTask();
          return;
        }

        const { agents, directors, sessions: serverSessions } = data;

        // Update sessions from server data
        sessions = {};
        sessionOrder = [];
        for (const s of serverSessions) {
          sessions[s.id] = {
            agentUrl: s.agent_url,
            tasks: s.tasks ? s.tasks.map(t => ({
              taskId: t.task_id,
              state: t.state,
              prompt: t.prompt
            })) : [],
            createdAt: s.created_at
          };
          sessionOrder.push(s.id);
        }

        // Update agent table
        const agentTableBody = document.getElementById('agentTableBody');
        if (agents.length > 0) {
          agentTableBody.innerHTML = agents.map(renderAgentRow).join('');
        } else {
          agentTableBody.innerHTML = '<tr><td colspan="5" class="empty-message">No agents discovered</td></tr>';
        }
        document.getElementById('agentCount').textContent = agents.length;

        // Update director table
        const directorTableBody = document.getElementById('directorTableBody');
        if (directors.length > 0) {
          directorTableBody.innerHTML = directors.map(renderDirectorRow).join('');
        } else {
          directorTableBody.innerHTML = '<tr><td colspan="4" class="empty-message">No directors discovered</td></tr>';
        }
        document.getElementById('directorCount').textContent = directors.length;

        // Update agent select dropdown
        const agentSelect = document.getElementById('agentSelect');
        const currentValue = agentSelect.value;
        agentSelect.innerHTML = '<option value="">Select an idle agent...</option>' +
          agents.filter(a => a.state === 'idle').map(a =>
            `<option value="${a.url}">${a.url} (${a.state})</option>`
          ).join('');
        if (currentValue && agents.some(a => a.url === currentValue)) {
          agentSelect.value = currentValue;
        }

        // Poll active task if any
        if (activeTask) {
          await pollTask();
        }

        // Update sessions UI
        updateSessionsUI();
      } catch (err) {
        console.error('Refresh failed:', err);
      }
    }

    // Poll active task status
    async function pollTask() {
      if (!activeTask) return;

      try {
        const status = await api(`/api/task/${activeTask.taskId}?agent_url=${encodeURIComponent(activeTask.agentUrl)}`);

        const monitor = document.getElementById('taskMonitor');
        const details = document.getElementById('taskDetails');

        const stateColors = {
          'queued': 'bg-secondary',
          'working': 'bg-yellow',
          'completed': 'bg-green',
          'failed': 'bg-red',
          'cancelled': 'bg-orange'
        };

        details.innerHTML = `
          <div class="mb-2">
            <span class="badge ${stateColors[status.state] || 'bg-secondary'}" title="${status.state}">${stateIcon(status.state)}</span>
            <strong class="ms-2">${status.task_id}</strong>
          </div>
          <div class="small text-muted mb-2">
            Agent: ${activeTask.agentUrl}<br>
            Duration: ${status.duration_seconds ? status.duration_seconds.toFixed(1) + 's' : 'running...'}
          </div>
          ${status.output ? `<pre class="bg-dark text-light p-3 rounded" style="max-height: 300px; overflow: auto;">${escapeHtml(status.output)}</pre>` : ''}
          ${status.error ? `<div class="alert alert-danger">${escapeHtml(status.error.message)}</div>` : ''}
        `;
        monitor.style.display = 'block';

        // Update session state if completed
        if (['completed', 'failed', 'cancelled'].includes(status.state)) {
          if (activeTask.sessionId) {
            // Update on server
            await updateSessionTaskState(activeTask.sessionId, activeTask.taskId, status.state);
            // Update local cache
            if (sessions[activeTask.sessionId]) {
              const session = sessions[activeTask.sessionId];
              const taskEntry = session.tasks.find(t => t.taskId === activeTask.taskId);
              if (taskEntry) {
                taskEntry.state = status.state;
              }
            }
          }
          activeTask = null;
          scheduleRefresh(); // Switch to slow polling
        }
      } catch (err) {
        console.error('Task poll failed:', err);
      }
    }

    // Submit task
    document.getElementById('taskForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const btn = document.getElementById('submitBtn');
      const spinner = document.getElementById('submitSpinner');
      const result = document.getElementById('submitResult');

      btn.disabled = true;
      spinner.classList.remove('d-none');
      result.classList.remove('show', 'alert-success', 'alert-danger');

      try {
        const agentUrl = document.getElementById('agentSelect').value;
        const prompt = document.getElementById('prompt').value;
        const sessionId = document.getElementById('sessionSelect').value;

        const body = {
          agent_url: agentUrl,
          prompt: prompt
        };

        // Include session_id if continuing an existing session
        if (sessionId) {
          body.session_id = sessionId;
        }

        const timeout = parseInt(document.getElementById('timeout').value);
        if (timeout > 0) body.timeout_seconds = timeout;

        const model = document.getElementById('model').value;
        if (model) body.model = model;

        const resp = await api('/api/task', {
          method: 'POST',
          body: JSON.stringify(body)
        });

        result.className = 'mt-3 alert alert-success show';
        result.textContent = `Task submitted: ${resp.task_id} (session: ${resp.session_id ? resp.session_id.slice(0, 8) + '...' : 'new'})`;

        // Track session on server
        const sid = resp.session_id;
        if (sid) {
          await saveSessionTask(sid, agentUrl, resp.task_id, resp.status || 'working', prompt);
          // Update local cache
          if (!sessions[sid]) {
            sessions[sid] = { agentUrl: agentUrl, tasks: [], createdAt: new Date().toISOString() };
          }
          sessions[sid].tasks.push({ taskId: resp.task_id, state: resp.status || 'working', prompt: prompt });
        }

        // Start monitoring
        activeTask = { taskId: resp.task_id, agentUrl: resp.agent_url, sessionId: sid };
        scheduleRefresh(); // Switch to fast polling

        // Clear prompt but keep other fields for follow-ups
        document.getElementById('prompt').value = '';

        // Refresh to show agent as busy
        await refresh();

        // IMPORTANT: After refresh, select the session we just used/created
        // This ensures subsequent tasks go to the same session
        if (sid) {
          document.getElementById('sessionSelect').value = sid;
        }
      } catch (err) {
        result.className = 'mt-3 alert alert-danger show';
        result.textContent = `Error: ${err.message}`;
      } finally {
        btn.disabled = false;
        spinner.classList.add('d-none');
      }
    });

    // Helpers
    function stateIcon(state) {
      const icons = {
        'idle': '✓',
        'completed': '✓',
        'working': '●',
        'queued': '○',
        'failed': '✕',
        'cancelling': '⊘',
        'cancelled': '⊘'
      };
      return icons[state] || '?';
    }

    function formatUptime(seconds) {
      if (!seconds) return 'unknown';
      if (seconds < 60) return `${Math.floor(seconds)}s`;
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
      return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
    }

    // Adaptive polling - faster when task is active
    function scheduleRefresh() {
      const newInterval = activeTask ? POLL_ACTIVE : POLL_IDLE;
      if (newInterval !== pollInterval) {
        pollInterval = newInterval;
        if (refreshTimer) clearInterval(refreshTimer);
        refreshTimer = setInterval(refresh, pollInterval);
      }
    }

    // Start refresh loop
    refresh();
    refreshTimer = setInterval(refresh, pollInterval);
  </script>
</body>
</html>
