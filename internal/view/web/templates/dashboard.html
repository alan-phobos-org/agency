<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Agency Dashboard</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/core@1.0.0-beta17/dist/css/tabler.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    .status-badge { font-size: 0.75rem; }
    #submitResult { display: none; }
    #submitResult.show { display: block; }
    .table-component { margin-bottom: 0; }
    .table-component td, .table-component th { vertical-align: middle; padding: 0.5rem; }
    .table-component .task-col { max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .table-component .session-id { font-family: monospace; font-size: 0.85rem; }
    .table-component .btn-sm { padding: 0.2rem 0.5rem; font-size: 0.75rem; }
    .empty-message { color: var(--tblr-muted); font-style: italic; padding: 1rem; }
    .session-row { cursor: pointer; }
    .session-row:hover { background-color: var(--tblr-bg-surface-secondary); }
    .session-row.selected { background-color: var(--tblr-primary-lt); }
    .task-item { padding: 0.75rem 1rem; border-bottom: 1px solid var(--tblr-border-color); }
    .task-item:last-child { border-bottom: none; }
    .task-output { max-height: 300px; overflow: auto; font-size: 0.85rem; background: var(--tblr-bg-surface); border: 1px solid var(--tblr-border-color); padding: 0.75rem; border-radius: 4px; margin-top: 0.5rem; }
    .task-output pre { background: var(--tblr-bg-surface-dark); padding: 0.5rem; border-radius: 4px; overflow-x: auto; }
    .task-output code { font-size: 0.8rem; }
    .task-output p { margin-bottom: 0.5rem; }
    .task-output p:last-child { margin-bottom: 0; }
    .task-output ul, .task-output ol { margin-bottom: 0.5rem; padding-left: 1.5rem; }
    .task-prompt { font-size: 0.85rem; color: var(--tblr-muted); margin-top: 0.25rem; }
    .task-prompt-content { background: var(--tblr-bg-surface); border: 1px solid var(--tblr-border-color); padding: 0.5rem; border-radius: 4px; margin-top: 0.25rem; }
  </style>
</head>
<body class="theme-light">
  <div class="page">
    <header class="navbar navbar-expand-md navbar-light d-print-none">
      <div class="container-xl">
        <div class="navbar-nav flex-row order-md-last align-items-center">
          <span class="badge bg-green-lt me-3">Connected</span>
          <button class="btn btn-sm btn-ghost-secondary me-2" onclick="showDevicesModal()">Devices</button>
          <form action="/logout" method="POST" class="d-inline">
            <button type="submit" class="btn btn-sm btn-ghost-danger">Logout</button>
          </form>
        </div>
      </div>
    </header>

    <div class="page-wrapper">
      <div class="page-body">
        <div class="container-xl">
          <!-- Task Submission -->
          <div class="card mb-3">
            <div class="card-header">
              <h3 class="card-title">Submit Task</h3>
            </div>
            <div class="card-body">
              <form id="taskForm">
                <div class="row">
                  <div class="col-md-4 mb-3">
                    <label class="form-label">Context</label>
                    <select class="form-select" id="contextSelect">
                      <option value="manual">Manual</option>
                    </select>
                  </div>
                  <div class="col-md-4 mb-3">
                    <label class="form-label">Agent</label>
                    <select class="form-select" id="agentSelect" required>
                      <option value="">Select an idle agent...</option>
                    </select>
                  </div>
                  <div class="col-md-4 mb-3">
                    <label class="form-label">Session</label>
                    <select class="form-select" id="sessionSelect">
                      <option value="">New session</option>
                    </select>
                  </div>
                </div>
                <div id="manualOptions">
                  <div class="row">
                    <div class="col-md-2 mb-3">
                      <label class="form-label">Timeout (s)</label>
                      <input type="number" class="form-control" id="timeout" value="1800" min="1">
                    </div>
                    <div class="col-md-2 mb-3">
                      <label class="form-label">Model</label>
                      <select class="form-select" id="model">
                        <option value="opus" selected>Opus</option>
                        <option value="sonnet">Sonnet</option>
                        <option value="haiku">Haiku</option>
                      </select>
                    </div>
                    <div class="col-md-8 mb-3 d-flex align-items-end">
                      <label class="form-check form-switch mb-0">
                        <input class="form-check-input" type="checkbox" id="thinking" checked>
                        <span class="form-check-label">Extended thinking</span>
                      </label>
                    </div>
                  </div>
                </div>
                <div id="contextInfo" class="mb-3 alert alert-info" style="display: none;">
                  <strong id="contextName"></strong>: <span id="contextDescription"></span>
                  <div class="small text-muted mt-1" id="contextSettings"></div>
                </div>
                <div class="mb-3">
                  <label class="form-label">Prompt</label>
                  <textarea class="form-control" id="prompt" rows="4" required placeholder="Describe the task..."></textarea>
                </div>
                <button type="submit" class="btn btn-primary" id="submitBtn">
                  <span class="spinner-border spinner-border-sm d-none" id="submitSpinner"></span>
                  Submit Task
                </button>
              </form>
              <div id="submitResult" class="mt-3 alert"></div>
            </div>
          </div>

          <!-- Session Detail (shown when a session is selected) -->
          <div class="card mb-3" id="sessionDetail" style="display: none;">
            <div class="card-header">
              <h3 class="card-title">Session <span id="sessionDetailId" class="text-muted"></span></h3>
              <div class="card-actions">
                <button class="btn btn-sm btn-ghost-secondary" onclick="closeSessionDetail()">✕</button>
              </div>
            </div>
            <div class="card-body p-0">
              <div id="sessionDetailContent"></div>
            </div>
          </div>

          <!-- Sessions Section -->
          <div class="card mb-3">
            <div class="card-header">
              <h3 class="card-title">Sessions</h3>
              <div class="card-actions">
                <span class="badge bg-purple" id="sessionCount">0</span>
              </div>
            </div>
            <div class="table-responsive">
              <table class="table table-vcenter table-component" id="sessionTable">
                <thead>
                  <tr>
                    <th style="width: 60px;">Status</th>
                    <th style="width: 120px;">Session</th>
                    <th>Agent</th>
                    <th style="width: 60px;">Tasks</th>
                    <th>Last Prompt</th>
                    <th style="width: 80px;"></th>
                  </tr>
                </thead>
                <tbody id="sessionTableBody">
                  <tr><td colspan="6" class="empty-message">No active sessions</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Agents Section -->
          <div class="card mb-3">
            <div class="card-header">
              <h3 class="card-title">Agents</h3>
              <div class="card-actions">
                <span class="badge bg-azure" id="agentCount">0</span>
              </div>
            </div>
            <div class="table-responsive">
              <table class="table table-vcenter table-component" id="agentTable">
                <thead>
                  <tr>
                    <th style="width: 60px;">Status</th>
                    <th>URL</th>
                    <th style="width: 80px;">Version</th>
                    <th style="width: 80px;">Uptime</th>
                    <th>Current Task</th>
                  </tr>
                </thead>
                <tbody id="agentTableBody">
                  <tr><td colspan="5" class="empty-message">No agents discovered</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Directors Section -->
          <div class="card mb-3">
            <div class="card-header">
              <h3 class="card-title">Directors</h3>
              <div class="card-actions">
                <span class="badge bg-purple" id="directorCount">0</span>
              </div>
            </div>
            <div class="table-responsive">
              <table class="table table-vcenter table-component" id="directorTable">
                <thead>
                  <tr>
                    <th style="width: 60px;">Status</th>
                    <th>URL</th>
                    <th style="width: 80px;">Version</th>
                    <th style="width: 80px;">Uptime</th>
                  </tr>
                </thead>
                <tbody id="directorTableBody">
                  <tr><td colspan="4" class="empty-message">No directors discovered</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Scheduler Section -->
          <div class="card mb-3" id="schedulerSection" style="display: none;">
            <div class="card-header">
              <h3 class="card-title">Scheduler</h3>
              <div class="card-actions">
                <span class="badge bg-green" id="schedulerStatus">Running</span>
              </div>
            </div>
            <div class="table-responsive">
              <table class="table table-vcenter table-component" id="schedulerTable">
                <thead>
                  <tr>
                    <th>Job</th>
                    <th style="width: 120px;">Schedule</th>
                    <th style="width: 160px;">Next Run</th>
                    <th style="width: 160px;">Last Run</th>
                  </tr>
                </thead>
                <tbody id="schedulerTableBody">
                  <tr><td colspan="4" class="empty-message">No jobs configured</td></tr>
                </tbody>
              </table>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <!-- Devices Modal -->
  <div class="modal modal-blur fade" id="devicesModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Device Management</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <button class="btn btn-primary w-100" onclick="generatePairingCode()">
              Generate Pairing Code
            </button>
          </div>
          <div id="pairingCodeDisplay" class="alert alert-info" style="display: none;">
            <div class="text-center">
              <div class="text-muted small mb-1">Enter this code on your new device:</div>
              <div class="display-6 font-monospace mb-1" id="pairingCode"></div>
              <div class="text-muted small">Expires in <span id="pairingExpiry"></span></div>
            </div>
          </div>
          <hr>
          <h6>Active Sessions</h6>
          <div id="devicesList" class="list-group list-group-flush">
            <div class="text-muted small">Loading...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tabler/core@1.0.0-beta17/dist/js/tabler.min.js"></script>
  <script>
    // Tracked task for monitoring
    let activeTask = null;

    // Sessions storage - fetched from server for global access
    let sessions = {};
    let sessionOrder = []; // Maintain server's sort order (newest first)

    // Contexts storage
    let contexts = [];

    // Selected session for detail view
    let selectedSession = null;

    // ETag for caching
    let dashboardETag = null;

    // Adaptive polling interval (ms)
    const POLL_IDLE = 5000;    // 5s when idle
    const POLL_ACTIVE = 1000;  // 1s when task running
    let pollInterval = POLL_IDLE;
    let refreshTimer = null;

    // Save task to server session
    async function saveSessionTask(sessionId, agentUrl, taskId, state, prompt) {
      try {
        await api('/api/sessions', {
          method: 'POST',
          body: JSON.stringify({
            session_id: sessionId,
            agent_url: agentUrl,
            task_id: taskId,
            state: state,
            prompt: prompt
          })
        });
      } catch (err) {
        console.error('Failed to save session task:', err);
      }
    }

    // Update task state on server
    async function updateSessionTaskState(sessionId, taskId, state) {
      try {
        await api(`/api/sessions/${sessionId}/tasks/${taskId}`, {
          method: 'PUT',
          body: JSON.stringify({ state: state })
        });
      } catch (err) {
        console.error('Failed to update session task state:', err);
      }
    }

    // API helper (uses cookies for auth)
    async function api(path, options = {}) {
      const resp = await fetch(path, {
        ...options,
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json',
          ...(options.headers || {})
        }
      });

      if (!resp.ok) {
        const err = await resp.json().catch(() => ({ message: resp.statusText }));
        throw new Error(err.message || `HTTP ${resp.status}`);
      }
      return resp.json();
    }

    // Device management functions
    let devicesModal = null;

    function showDevicesModal() {
      if (!devicesModal) {
        devicesModal = new bootstrap.Modal(document.getElementById('devicesModal'));
      }
      loadDevices();
      devicesModal.show();
    }

    async function loadDevices() {
      const devicesList = document.getElementById('devicesList');
      try {
        const devices = await api('/api/devices');
        if (devices.length === 0) {
          devicesList.innerHTML = '<div class="text-muted small">No active sessions</div>';
          return;
        }
        devicesList.innerHTML = devices.map(d => `
          <div class="list-group-item d-flex justify-content-between align-items-center">
            <div>
              <div class="fw-bold">${escapeHtml(d.label || 'Unknown Device')}${d.is_current ? ' <span class="badge bg-blue-lt">Current</span>' : ''}</div>
              <div class="text-muted small">
                ${d.ip_address} &middot; Last seen: ${new Date(d.last_seen).toLocaleString()}
              </div>
            </div>
            ${!d.is_current ? `<button class="btn btn-sm btn-ghost-danger" onclick="revokeDevice('${d.id}')">Revoke</button>` : ''}
          </div>
        `).join('');
      } catch (err) {
        devicesList.innerHTML = `<div class="text-danger small">Error: ${escapeHtml(err.message)}</div>`;
      }
    }

    async function generatePairingCode() {
      const display = document.getElementById('pairingCodeDisplay');
      const codeEl = document.getElementById('pairingCode');
      const expiryEl = document.getElementById('pairingExpiry');

      try {
        const resp = await api('/api/pair/code', { method: 'POST' });
        codeEl.textContent = resp.code;
        expiryEl.textContent = `${Math.floor(resp.expires_in / 60)} minutes`;
        display.style.display = 'block';
      } catch (err) {
        alert('Failed to generate pairing code: ' + err.message);
      }
    }

    async function revokeDevice(deviceId) {
      if (!confirm('Revoke access for this device?')) return;

      try {
        await api(`/api/devices/${deviceId}`, { method: 'DELETE' });
        loadDevices(); // Refresh list
      } catch (err) {
        alert('Failed to revoke device: ' + err.message);
      }
    }

    // Fetch and populate contexts
    async function loadContexts() {
      try {
        contexts = await api('/api/contexts');
        const contextSelect = document.getElementById('contextSelect');
        contextSelect.innerHTML = contexts.map(ctx =>
          `<option value="${ctx.id}">${ctx.name}</option>`
        ).join('');
        // Select first non-manual context by default if available
        const firstNonManual = contexts.find(c => c.id !== 'manual');
        if (firstNonManual) {
          contextSelect.value = firstNonManual.id;
        }
        // Trigger change to update UI
        updateContextUI();
      } catch (err) {
        console.error('Failed to load contexts:', err);
      }
    }

    // Update UI based on selected context
    function updateContextUI() {
      const contextId = document.getElementById('contextSelect').value;
      const ctx = contexts.find(c => c.id === contextId);
      const manualOptions = document.getElementById('manualOptions');
      const contextInfo = document.getElementById('contextInfo');

      if (contextId === 'manual' || !ctx) {
        manualOptions.style.display = 'block';
        contextInfo.style.display = 'none';
      } else {
        manualOptions.style.display = 'none';
        contextInfo.style.display = 'block';
        document.getElementById('contextName').textContent = ctx.name;
        document.getElementById('contextDescription').textContent = ctx.description || '';

        // Show context settings
        const settings = [];
        if (ctx.model) settings.push(`Model: ${ctx.model}`);
        if (ctx.timeout_seconds) settings.push(`Timeout: ${ctx.timeout_seconds}s`);
        if (ctx.thinking !== undefined) settings.push(`Thinking: ${ctx.thinking ? 'on' : 'off'}`);
        document.getElementById('contextSettings').textContent = settings.join(' | ');
      }
    }

    // Get current context settings
    function getContextSettings() {
      const contextId = document.getElementById('contextSelect').value;
      const ctx = contexts.find(c => c.id === contextId);

      if (contextId === 'manual' || !ctx) {
        return {
          model: document.getElementById('model').value,
          timeout_seconds: parseInt(document.getElementById('timeout').value) || 1800,
          thinking: document.getElementById('thinking').checked,
          prompt_prefix: ''
        };
      }

      return {
        model: ctx.model || 'opus',
        timeout_seconds: ctx.timeout_seconds || 1800,
        thinking: ctx.thinking !== undefined ? ctx.thinking : true,
        prompt_prefix: ctx.prompt_prefix || ''
      };
    }

    // Context change handler
    document.getElementById('contextSelect').addEventListener('change', updateContextUI);

    // Fetch dashboard data with ETag support
    async function fetchDashboard() {
      const headers = { 'Content-Type': 'application/json' };
      if (dashboardETag) headers['If-None-Match'] = dashboardETag;

      const resp = await fetch('/api/dashboard', {
        credentials: 'same-origin',
        headers
      });

      if (resp.status === 304) {
        return null; // No change
      }

      if (!resp.ok) {
        const err = await resp.json().catch(() => ({ message: resp.statusText }));
        throw new Error(err.message || `HTTP ${resp.status}`);
      }

      dashboardETag = resp.headers.get('ETag');
      return resp.json();
    }

    // Render agent table row
    function renderAgentRow(agent) {
      const stateColors = {
        'idle': 'bg-green',
        'working': 'bg-yellow',
        'cancelling': 'bg-orange'
      };
      const stateColor = stateColors[agent.state] || 'bg-secondary';

      let taskInfo = '—';
      if (agent.current_task) {
        const preview = escapeHtml(agent.current_task.prompt_preview || '');
        taskInfo = `<span class="task-col" title="${preview}">${agent.current_task.id}: ${preview}</span>`;
      }

      return `
        <tr>
          <td><span class="badge ${stateColor} status-badge" title="${agent.state}">${stateIcon(agent.state)} ${agent.state}</span></td>
          <td class="text-muted small">${agent.url}</td>
          <td class="small">${agent.version || '—'}</td>
          <td class="small">${formatUptime(agent.uptime_seconds)}</td>
          <td class="small">${taskInfo}</td>
        </tr>`;
    }

    // Render director table row
    function renderDirectorRow(director) {
      return `
        <tr>
          <td><span class="badge bg-purple status-badge">dir</span></td>
          <td class="text-muted small">${director.url}</td>
          <td class="small">${director.version || '—'}</td>
          <td class="small">${formatUptime(director.uptime_seconds)}</td>
        </tr>`;
    }

    // Render scheduler job row
    function renderSchedulerJobRow(job, agentUrl) {
      const nextRun = job.next_run ? new Date(job.next_run).toLocaleString() : '—';
      let lastRunHtml = '—';

      if (job.last_run && job.last_task_id) {
        const lastRunTime = new Date(job.last_run).toLocaleString();
        const statusColors = {
          'submitted': 'text-success',
          'skipped_busy': 'text-warning',
          'skipped_error': 'text-danger'
        };
        const statusClass = statusColors[job.last_status] || 'text-muted';
        // Find session containing this task
        const sessionId = findSessionByTaskId(job.last_task_id);
        if (sessionId) {
          lastRunHtml = `<a href="#" class="${statusClass}" onclick="openSessionDetail('${sessionId}'); return false;" title="${job.last_status}">${lastRunTime}</a>`;
        } else {
          lastRunHtml = `<span class="${statusClass}" title="${job.last_status}">${lastRunTime}</span>`;
        }
      } else if (job.last_run) {
        lastRunHtml = new Date(job.last_run).toLocaleString();
      }

      return `
        <tr>
          <td class="small">${escapeHtml(job.name)}</td>
          <td class="text-muted small font-monospace">${escapeHtml(job.schedule)}</td>
          <td class="small">${nextRun}</td>
          <td class="small">${lastRunHtml}</td>
        </tr>`;
    }

    // Find session containing a task ID
    function findSessionByTaskId(taskId) {
      for (const sessionId of sessionOrder) {
        const session = sessions[sessionId];
        if (session && session.tasks) {
          for (const task of session.tasks) {
            if (task.taskId === taskId) {
              return sessionId;
            }
          }
        }
      }
      return null;
    }

    // Render session table row
    function renderSessionRow(sessionId, session) {
      const taskCount = session.tasks ? session.tasks.length : 0;
      const lastTask = session.tasks && session.tasks.length > 0 ? session.tasks[session.tasks.length - 1] : null;
      const stateColors = {
        'completed': 'bg-green',
        'failed': 'bg-red',
        'working': 'bg-yellow',
        'queued': 'bg-secondary'
      };
      const lastState = lastTask ? lastTask.state : 'unknown';
      const lastPrompt = lastTask ? escapeHtml((lastTask.prompt || '').slice(0, 50)) : '—';
      const fullPrompt = lastTask ? escapeHtml(lastTask.prompt || '') : '';
      const isSelected = selectedSession === sessionId ? 'selected' : '';

      return `
        <tr class="session-row ${isSelected}" onclick="openSessionDetail('${sessionId}')" data-session="${sessionId}">
          <td><span class="badge ${stateColors[lastState] || 'bg-secondary'} status-badge" title="${lastState}">${stateIcon(lastState)}</span></td>
          <td class="session-id">${sessionId.slice(0, 8)}...</td>
          <td class="text-muted small">${session.agentUrl}</td>
          <td class="text-center">${taskCount}</td>
          <td class="small task-col" title="${fullPrompt}">${lastPrompt}${(lastTask?.prompt || '').length > 50 ? '...' : ''}</td>
          <td><button class="btn btn-sm btn-outline-primary" onclick="event.stopPropagation(); continueSession('${sessionId}')">Continue</button></td>
        </tr>`;
    }

    // Update scheduler display
    function updateSchedulerUI(helpers) {
      const schedulerSection = document.getElementById('schedulerSection');
      const schedulerStatus = document.getElementById('schedulerStatus');
      const schedulerTableBody = document.getElementById('schedulerTableBody');

      // Find scheduler helper (first one with jobs)
      const scheduler = helpers.find(h => h.config && h.config.agent_url);

      if (!scheduler) {
        schedulerSection.style.display = 'none';
        return;
      }

      schedulerSection.style.display = 'block';

      // Update status badge
      if (scheduler.state === 'running') {
        schedulerStatus.className = 'badge bg-green';
        schedulerStatus.textContent = 'Running';
      } else {
        schedulerStatus.className = 'badge bg-red';
        schedulerStatus.textContent = scheduler.state || 'Offline';
      }

      // Render jobs - jobs are in the raw status response, need to access via config or direct property
      const jobs = scheduler.jobs || [];
      if (jobs.length > 0) {
        schedulerTableBody.innerHTML = jobs.map(job => renderSchedulerJobRow(job, scheduler.config.agent_url)).join('');
      } else {
        schedulerTableBody.innerHTML = '<tr><td colspan="4" class="empty-message">No jobs configured</td></tr>';
      }
    }

    // Update sessions display
    function updateSessionsUI() {
      const sessionTableBody = document.getElementById('sessionTableBody');
      const sessionSelect = document.getElementById('sessionSelect');

      document.getElementById('sessionCount').textContent = sessionOrder.length;

      if (sessionOrder.length > 0) {
        sessionTableBody.innerHTML = sessionOrder.map(id => renderSessionRow(id, sessions[id])).join('');
      } else {
        sessionTableBody.innerHTML = '<tr><td colspan="6" class="empty-message">No active sessions</td></tr>';
      }

      // Update session dropdown, preserving current selection
      const currentSessionValue = sessionSelect.value;
      sessionSelect.innerHTML = '<option value="">New session</option>' +
        sessionOrder.map(id => {
          const s = sessions[id];
          const taskCount = s.tasks ? s.tasks.length : 0;
          return `<option value="${id}">${id.slice(0, 8)}... (${taskCount} tasks, ${s.agentUrl})</option>`;
        }).join('');
      if (currentSessionValue && sessionOrder.includes(currentSessionValue)) {
        sessionSelect.value = currentSessionValue;
      }
    }

    // Continue session - pre-fill form
    function continueSession(sessionId) {
      const session = sessions[sessionId];
      if (!session) return;

      document.getElementById('sessionSelect').value = sessionId;
      document.getElementById('agentSelect').value = session.agentUrl;
      document.getElementById('prompt').focus();
    }

    // Open session detail view
    async function openSessionDetail(sessionId) {
      const session = sessions[sessionId];
      if (!session) return;

      selectedSession = sessionId;
      updateSessionsUI(); // Update selection highlighting

      const detailDiv = document.getElementById('sessionDetail');
      const detailId = document.getElementById('sessionDetailId');
      const content = document.getElementById('sessionDetailContent');

      detailId.textContent = sessionId.slice(0, 8) + '...';
      content.innerHTML = '<div class="p-3 text-muted">Loading history...</div>';
      detailDiv.style.display = 'block';

      // Fetch history for each task from the agent
      const tasks = session.tasks || [];
      if (tasks.length === 0) {
        content.innerHTML = '<div class="p-3 text-muted">No tasks in this session</div>';
        return;
      }

      const historyItems = [];
      const terminalStates = ['completed', 'failed', 'cancelled'];
      for (const task of tasks) {
        // Only fetch history for completed tasks - in-progress tasks won't have history yet
        if (terminalStates.includes(task.state)) {
          try {
            const history = await fetchTaskHistory(session.agentUrl, task.taskId);
            historyItems.push({ ...task, history });
          } catch (err) {
            historyItems.push({ ...task, history: null, error: err.message });
          }
        } else {
          // For in-progress tasks, just use the local session data
          historyItems.push({ ...task, history: null });
        }
      }

      renderSessionDetail(historyItems);
    }

    // Fetch task history via proxy (avoids mixed content issues)
    async function fetchTaskHistory(agentUrl, taskId) {
      return api(`/api/history/${taskId}?agent_url=${encodeURIComponent(agentUrl)}`);
    }

    // Render markdown safely
    function renderMarkdown(text) {
      if (!text) return '';
      try {
        return marked.parse(text);
      } catch (e) {
        return escapeHtml(text);
      }
    }

    // Render session detail content
    function renderSessionDetail(tasks) {
      const content = document.getElementById('sessionDetailContent');
      const stateColors = {
        'completed': 'bg-green',
        'failed': 'bg-red',
        'working': 'bg-yellow',
        'queued': 'bg-secondary',
        'cancelled': 'bg-orange',
        'unknown': 'bg-secondary'
      };

      const html = tasks.map((task, i) => {
        const state = task.history?.state || task.state || 'unknown';
        // Prefer session's stored prompt (no context prefix) over history prompt
        const prompt = task.prompt || task.history?.prompt || '';
        const output = task.history?.output || '';
        const error = task.history?.error?.message || task.error || '';
        const duration = task.history?.duration_seconds;
        const steps = task.history?.steps || [];

        let outputHtml = '';
        if (output) {
          outputHtml = `<div class="task-output">${renderMarkdown(output)}</div>`;
        } else if (steps.length > 0) {
          // Show steps outline if no full output
          const stepsText = steps.map(s => {
            const preview = s.output_preview || s.input_preview || s.type;
            return s.tool ? `[${s.tool}] ${preview}` : preview;
          }).join('\n');
          outputHtml = `<div class="task-output"><pre>${escapeHtml(stepsText)}</pre></div>`;
        }

        // Render prompt with markdown
        const promptHtml = prompt
          ? `<div class="task-prompt">Prompt:</div><div class="task-prompt-content">${renderMarkdown(prompt)}</div>`
          : '';

        return `
          <div class="task-item">
            <div class="d-flex align-items-center justify-content-between">
              <div>
                <span class="badge ${stateColors[state] || 'bg-secondary'} status-badge me-2">${stateIcon(state)}</span>
                <strong class="small">${task.taskId}</strong>
                ${duration ? `<span class="text-muted small ms-2">${duration.toFixed(1)}s</span>` : ''}
              </div>
              <span class="text-muted small">#${i + 1}</span>
            </div>
            ${promptHtml}
            ${error ? `<div class="alert alert-danger mt-2 mb-0 p-2 small">${escapeHtml(error)}</div>` : ''}
            ${outputHtml}
          </div>`;
      }).join('');

      content.innerHTML = html || '<div class="p-3 text-muted">No tasks</div>';
    }

    // Close session detail view
    function closeSessionDetail() {
      selectedSession = null;
      document.getElementById('sessionDetail').style.display = 'none';
      updateSessionsUI();
    }

    // Update dashboard
    async function refresh() {
      try {
        const data = await fetchDashboard();

        // If 304 (no change), only poll active task
        if (data === null) {
          if (activeTask) await pollTask();
          return;
        }

        const { agents, directors, helpers, sessions: serverSessions } = data;

        // Update scheduler section
        updateSchedulerUI(helpers || []);

        // Update sessions from server data
        sessions = {};
        sessionOrder = [];
        for (const s of serverSessions) {
          sessions[s.id] = {
            agentUrl: s.agent_url,
            tasks: s.tasks ? s.tasks.map(t => ({
              taskId: t.task_id,
              state: t.state,
              prompt: t.prompt
            })) : [],
            createdAt: s.created_at
          };
          sessionOrder.push(s.id);
        }

        // Update agent table
        const agentTableBody = document.getElementById('agentTableBody');
        if (agents.length > 0) {
          agentTableBody.innerHTML = agents.map(renderAgentRow).join('');
        } else {
          agentTableBody.innerHTML = '<tr><td colspan="5" class="empty-message">No agents discovered</td></tr>';
        }
        document.getElementById('agentCount').textContent = agents.length;

        // Update director table
        const directorTableBody = document.getElementById('directorTableBody');
        if (directors.length > 0) {
          directorTableBody.innerHTML = directors.map(renderDirectorRow).join('');
        } else {
          directorTableBody.innerHTML = '<tr><td colspan="4" class="empty-message">No directors discovered</td></tr>';
        }
        document.getElementById('directorCount').textContent = directors.length;

        // Update agent select dropdown
        const agentSelect = document.getElementById('agentSelect');
        const currentValue = agentSelect.value;
        const idleAgents = agents.filter(a => a.state === 'idle');
        agentSelect.innerHTML = '<option value="">Select an idle agent...</option>' +
          idleAgents.map(a =>
            `<option value="${a.url}">${a.url} (${a.state})</option>`
          ).join('');
        if (currentValue && agents.some(a => a.url === currentValue)) {
          agentSelect.value = currentValue;
        } else if (idleAgents.length === 1) {
          // Auto-select if there's only one idle agent
          agentSelect.value = idleAgents[0].url;
        }

        // Poll active task if any
        if (activeTask) {
          await pollTask();
        }

        // Update sessions UI
        updateSessionsUI();
      } catch (err) {
        console.error('Refresh failed:', err);
      }
    }

    // Poll active task status
    async function pollTask() {
      if (!activeTask) return;

      try {
        // Include session_id so server can auto-update session store if task completed
        let url = `/api/task/${activeTask.taskId}?agent_url=${encodeURIComponent(activeTask.agentUrl)}`;
        if (activeTask.sessionId) {
          url += `&session_id=${encodeURIComponent(activeTask.sessionId)}`;
        }
        const status = await api(url);

        // Update session state if completed
        if (['completed', 'failed', 'cancelled'].includes(status.state)) {
          if (activeTask.sessionId) {
            // Update on server
            await updateSessionTaskState(activeTask.sessionId, activeTask.taskId, status.state);
            // Update local cache
            if (sessions[activeTask.sessionId]) {
              const session = sessions[activeTask.sessionId];
              const taskEntry = session.tasks.find(t => t.taskId === activeTask.taskId);
              if (taskEntry) {
                taskEntry.state = status.state;
              }
            }
            // Refresh session detail if this session is selected
            if (selectedSession === activeTask.sessionId) {
              openSessionDetail(activeTask.sessionId);
            }
          }
          activeTask = null;
          scheduleRefresh(); // Switch to slow polling
        }
      } catch (err) {
        console.error('Task poll failed:', err);
        // On error, check if task completed and moved to history
        if (activeTask) {
          try {
            const history = await api(`/api/history/${activeTask.taskId}?agent_url=${encodeURIComponent(activeTask.agentUrl)}`);
            if (history && history.state) {
              // Task found in history - update state
              if (activeTask.sessionId) {
                await updateSessionTaskState(activeTask.sessionId, activeTask.taskId, history.state);
                if (sessions[activeTask.sessionId]) {
                  const session = sessions[activeTask.sessionId];
                  const taskEntry = session.tasks.find(t => t.taskId === activeTask.taskId);
                  if (taskEntry) {
                    taskEntry.state = history.state;
                  }
                }
              }
              activeTask = null;
              scheduleRefresh();
            }
          } catch (historyErr) {
            // Task not found in history either - may still be running or agent unavailable
            console.error('History lookup also failed:', historyErr);
          }
        }
      }
    }

    // Reconcile stale "working" tasks on page load
    // Checks all tasks marked as "working" against the agent to fix stuck states
    async function reconcileWorkingSessions() {
      const reconcilePromises = [];

      for (const sessionId of sessionOrder) {
        const session = sessions[sessionId];
        if (!session || !session.tasks) continue;

        for (const task of session.tasks) {
          if (task.state === 'working') {
            // Check actual state from agent
            const promise = (async () => {
              try {
                const url = `/api/task/${task.taskId}?agent_url=${encodeURIComponent(session.agentUrl)}&session_id=${encodeURIComponent(sessionId)}`;
                const status = await api(url);
                if (status.state !== 'working') {
                  // State changed - update
                  await updateSessionTaskState(sessionId, task.taskId, status.state);
                  task.state = status.state;
                  return true; // Changed
                }
              } catch (err) {
                // Task not found in active tasks, check history
                try {
                  const history = await api(`/api/history/${task.taskId}?agent_url=${encodeURIComponent(session.agentUrl)}`);
                  if (history && history.state) {
                    await updateSessionTaskState(sessionId, task.taskId, history.state);
                    task.state = history.state;
                    return true; // Changed
                  }
                } catch {
                  // Task not found anywhere - mark as unknown
                  await updateSessionTaskState(sessionId, task.taskId, 'unknown');
                  task.state = 'unknown';
                  return true; // Changed
                }
              }
              return false; // No change
            })();
            reconcilePromises.push(promise);
          }
        }
      }

      if (reconcilePromises.length > 0) {
        const results = await Promise.all(reconcilePromises);
        const changedCount = results.filter(r => r).length;
        if (changedCount > 0) {
          console.log(`Reconciled ${changedCount} stale working task(s)`);
          updateSessionsUI();
        }
      }
    }

    // Submit task
    document.getElementById('taskForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const btn = document.getElementById('submitBtn');
      const spinner = document.getElementById('submitSpinner');
      const result = document.getElementById('submitResult');

      btn.disabled = true;
      spinner.classList.remove('d-none');
      result.classList.remove('show', 'alert-success', 'alert-danger');

      try {
        const agentUrl = document.getElementById('agentSelect').value;
        const userPrompt = document.getElementById('prompt').value;
        const sessionId = document.getElementById('sessionSelect').value;

        // Get settings from context or manual inputs
        const settings = getContextSettings();

        // Build prompt with optional context prefix
        const fullPrompt = settings.prompt_prefix
          ? settings.prompt_prefix + userPrompt
          : userPrompt;

        const body = {
          agent_url: agentUrl,
          prompt: fullPrompt,
          model: settings.model,
          timeout_seconds: settings.timeout_seconds,
          thinking: settings.thinking
        };

        // Include session_id if continuing an existing session
        if (sessionId) {
          body.session_id = sessionId;
        }

        const resp = await api('/api/task', {
          method: 'POST',
          body: JSON.stringify(body)
        });

        result.className = 'mt-3 alert alert-success show';
        result.textContent = `Task submitted: ${resp.task_id} (session: ${resp.session_id ? resp.session_id.slice(0, 8) + '...' : 'new'})`;

        // Track session on server
        const sid = resp.session_id;
        if (sid) {
          await saveSessionTask(sid, agentUrl, resp.task_id, resp.status || 'working', userPrompt);
          // Update local cache
          if (!sessions[sid]) {
            sessions[sid] = { agentUrl: agentUrl, tasks: [], createdAt: new Date().toISOString() };
            sessionOrder.unshift(sid);
          }
          sessions[sid].tasks.push({ taskId: resp.task_id, state: resp.status || 'working', prompt: userPrompt });
        }

        // Start monitoring
        activeTask = { taskId: resp.task_id, agentUrl: resp.agent_url, sessionId: sid };
        scheduleRefresh(); // Switch to fast polling

        // Clear prompt but keep other fields for follow-ups
        document.getElementById('prompt').value = '';

        // Refresh to show agent as busy and open session detail
        await refresh();

        // Select session and open its detail view
        if (sid) {
          document.getElementById('sessionSelect').value = sid;
          openSessionDetail(sid);
        }
      } catch (err) {
        result.className = 'mt-3 alert alert-danger show';
        result.textContent = `Error: ${err.message}`;
      } finally {
        btn.disabled = false;
        spinner.classList.add('d-none');
      }
    });

    // Helpers
    function stateIcon(state) {
      const icons = {
        'idle': '✓',
        'completed': '✓',
        'working': '●',
        'queued': '○',
        'failed': '✕',
        'cancelling': '⊘',
        'cancelled': '⊘',
        'unknown': '?'
      };
      return icons[state] || '?';
    }

    function formatUptime(seconds) {
      if (!seconds) return 'unknown';
      if (seconds < 60) return `${Math.floor(seconds)}s`;
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
      return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
    }

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
    }

    // Adaptive polling - faster when task is active
    function scheduleRefresh() {
      const newInterval = activeTask ? POLL_ACTIVE : POLL_IDLE;
      if (newInterval !== pollInterval) {
        pollInterval = newInterval;
        if (refreshTimer) clearInterval(refreshTimer);
        refreshTimer = setInterval(refresh, pollInterval);
      }
    }

    // Start refresh loop
    loadContexts(); // Load available contexts
    refresh().then(() => {
      // After initial load, reconcile any stale "working" tasks
      reconcileWorkingSessions();
    });
    refreshTimer = setInterval(refresh, pollInterval);
  </script>
</body>
</html>
